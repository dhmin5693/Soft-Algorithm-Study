/*
 * 이 문제는 이전 칸들 중 현재 칸에 도달할 수 있는 칸들을 모두 찾아서
 * dp값을 비교하여 최솟값을 +1하여 현재 칸의 dp값으로 갱신해주는 방식으로 진행하였습니다.
 * 이전 칸을 모두 비교하였음에도 현재 칸의 값이 갱신되지 않았다면
 * 현재 칸에 도달할 수 있는 방법이 없다는 것을 뜻하므로 -1을 출력하도록 하였습니다.
*/

#include<iostream>
#include<algorithm>

using namespace std;

int main(void){
    int dp[1105]={0};
    int arr[1105]={0}; // Ai가 최대 100이므로 혹시 몰라서 일단 100칸 더
    fill_n(dp,1105,1001);
    // dp배열은 최솟값을 구해야 하므로 최대 점프횟수인 1001로 초기화
    int n;
    cin>>n;

    for(int i=0;i<n;i++){
        scanf("%d",&arr[i]);
    }

    // n이 1개가 아니지만 arr[0]이 0인 경우 ( 다음 칸으로 갈 수 없음 )
    if(arr[0]==0&&n!=1){
        printf("-1");
        return 0;
    }
    // n이 1개지만 arr[0]이 0인 경우 ( 이미 처음칸이자 끝 칸에 도달함 )
    else if(arr[0]==0&&n==1){
        printf("0");
        return 0;
    }
    dp[0]=1;
    for(int i=0;i<n;i++){
        for(int j=0;j<i;j++){
            // i보다 작은 j번째 칸의 인덱스와 점프 칸 수의 합이 i보다 크거나 같은 경우
            // 즉, 점프해서 i에 도달할 수 있는 경우
            if(j+arr[j]>=i){
                // 이전에 점프해서 온 칸의 값 중 최소 점프 횟수와
                // 비교하여 최솟값을 저장
                dp[i]=min(dp[i],dp[j]+1);
            }
        }
        // 비교를 거쳤음에도 1001이 저장되어 있다면 점프해서 도달할 수 없는 칸
        // 즉, 점프가 이 부분에서 끊겼음을 의미
        if(dp[i]==1001){
            printf("-1");
            return 0;
        }
    }
    
    // 끝 칸의 dp값을 출력
    // 첫 칸을 1로 초기화하였으므로 -1하여 출력
    printf("%d",dp[n-1]-1);

}
